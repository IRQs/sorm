package vorm

import vorm._
import reflection._
import structure._

package object resultSetSelect {
  
  
  sealed case class Statement
    ( template : String,
      values : Seq[(Any, JdbcType)],
      //  should really be just direct mappings to values, if only they somehow covered special columns like index
      resultSetColumns : Seq[(ddl.Column, mapping.Table)] )
  
  private type JdbcType = Int



  def statement
    ( q : Query )
    : Statement
    = {




      lazy val pksSelect
        = {

          def selectWithWhereNode
            ( n : Query.WhereNode,
              s : Select )
            : Select
            = n match {
                case Query.WhereNode.Filter( k, m : mapping.Seq, v : Seq[_] )
                  ⇒ s.copy(
                        having
                          = Nil :+
                            sql.HavingClause(
                                sql.Count(
                                    distinct = true,
                                    columns = 
                                  )
                              )
                      )
              }

          val columns
            = q.mapping.primaryKeyColumns
                .toStream
                .map(_.name)
                .map(sql.Column(_, mainTreeTableAlias(q.mapping).some))

          //  no. The tree should be generated by each clause individually for ability to create OR clauses.
          basisSelect
            .foldTo(q.where)(selectWithWhereNode)
            .copy(columns = columns, groupBy = columns)

        }


      //  PLAIN

      val mainTreeTableAlias
        : mapping.Table ⇒ String
        = new collection.mutable.HashMap[mapping.Table, String]() {
            override def default
              ( m : mapping.Table )
              = {
                val n = "t" + size
                update(m, n)
                n
              }
          }

      val filterNodeTableAlias
        : Query.WhereNode ⇒ String
        = ???


      lazy val basisSelect
        : Select
        = {
          def join
            ( m : mapping.Table,
              s : Select )
            : Select
            = s.copy(
                  columns 
                    = m.resultSetColumns
                        .toStream
                        .map(_.name)
                        .map(sql.Column(_, mainTreeTableAlias(m).some)) ++:
                      s.columns,
                  joins
                    = sql.Join(
                          name = m.tableName,
                          alias = mainTreeTableAlias(m).some,
                          targetTable = mainTreeTableAlias(m.ownerTableMapping),
                          on = m.ownerTableColumnMappings
                        ) +:
                      s.joins
                )

          Select(
              columns 
                = q.mapping.resultSetColumns
                    .toStream
                    .map(_.name)
                    .map(sql.Column(_, mainTreeTableAlias(q.mapping).some)),
              from 
                = sql.From(
                      q.mapping.tableName, 
                      mainTreeTableAlias(q.mapping).some
                    )
            ) 
            .foldTo( q.mapping.subTableMappings )( join )
        }



      def statement
        ( select : Select )
        : Statement
        = ???


      unfilteredSelect(q.mapping)
        .foldTo(q.where)(filtered)
        .applyTo(statement)

    }

}