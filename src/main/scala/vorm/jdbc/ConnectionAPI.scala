package vorm.jdbc

import com.weiglewilczek.slf4s.Logging
import java.sql.{ResultSet, PreparedStatement, Connection, Statement => JStatement}
import org.joda.time.DateTime

class ConnectionAPI(connection: Connection) extends Logging {

  def select(stmt: Statement): ResultSet = {
    throw new NotImplementedError
  }
  /**
   * @return How many rows updated
   */
  def update(table: String, data: Map[String, Any], where: Map[String, Any]) = {
    require(data.nonEmpty, "Set clauses are required")
    require(where.nonEmpty, "Where clauses are required")

    val s =
      Statement(
        "UPDATE " + table +
        "\nSET " + data.keysIterator.map(_ + " = ?").mkString(", ") +
        "\nWHERE " + where.keysIterator.map(_ + " = ?").mkString(" AND "),

        data.values.toSeq ++ where.values
      )

    logger.info("Executing update:\n" + s)
    executeUpdate(s)
  }
  def insert(table: String, data: Map[String, Any]) {
    val stmt = insertStatement(table, data)
    logger.info("Executing insert:\n" + stmt)
    executeUpdate(stmt).ensuring(_ == 1)
  }
  /**
   * Either throw an exception or perform an insert and return autogenerated values result set for parsing
   * @return Autogenerated values
   */
  def insertAndGetId(table: String, data: Map[String, Any]): Long = {
    val stmt = insertStatement(table, data)
    logger.info("Executing insert:\n" + stmt)
    executeUpdateAndGetGeneratedKeys(stmt).getLong("id")
  }
  /**
   * @return How many rows deleted
   */
  def delete(table: String, where: Map[String, Any]): Int = {
    require(where.nonEmpty, "Where clauses are required")

    val s =
      Statement(
        "DELETE FROM " + table +
        "\nWHERE " + where.keysIterator.map(_ + " = ?").mkString(" AND "),

        where.values.toSeq
      )

    logger.info("Executing delete:\n" + s)
    executeUpdate(s)
  }
  private def executeUpdateAndGetGeneratedKeys(stmt: Statement) = {
    if (stmt.data.isEmpty) {
      val js = connection.createStatement()
      js.executeUpdate(stmt.sql).ensuring(_ == 1)
      js.getGeneratedKeys
    } else {
      val js = preparedStatement(stmt, true)
      js.executeUpdate().ensuring(_ == 1)
      js.getGeneratedKeys
    }
  }
  private def executeUpdate(stmt: Statement) = {
    if (stmt.data.isEmpty) connection.createStatement().executeUpdate(stmt.sql)
    else preparedStatement(stmt).executeUpdate()
  }

  private def insertStatement(table: String, data: Map[String, Any]) =
    Statement(
      "INSERT INTO " + table +
      "\n(" + data.ensuring(data.nonEmpty, "Set clauses are required").keysIterator.mkString(", ") + ")" +
      "\nVALUES (" + 1.to(data.size).map(_ => "?").mkString(", ") + ")",
      data.values.toSeq
    )

  private def preparedStatement(stmt: Statement, generatedKeys: Boolean = false) = {
    val s =
      connection.prepareStatement(
        stmt.sql,
        if (generatedKeys) JStatement.RETURN_GENERATED_KEYS
        else JStatement.NO_GENERATED_KEYS
      )
    stmt.data.zipWithIndex.foreach {
      case (v, i) => s.set(i, v)
    }

    s
  }


}