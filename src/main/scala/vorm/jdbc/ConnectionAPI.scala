package vorm.jdbc

import com.weiglewilczek.slf4s.Logging
import java.sql.{ResultSet, PreparedStatement, Connection, Statement => JStatement}
import org.joda.time.DateTime

class ConnectionAPI(connection: Connection) extends Logging {

  def select(stmt: Statement): ResultSet = {
    throw new NotImplementedError
  }
  /**
   * @return How many rows updated
   */
  def update(stmt: Statement): Int = {
    logger.info("Executing update:\n" + stmt)
    executeUpdate(stmt)
  }
  def insert(stmt: Statement) {
    logger.info("Executing insert:\n" + stmt)
    executeUpdate(stmt).ensuring(_ == 1)
  }
  /**
   * Either throw an exception or perform an insert and return autogenerated values result set for parsing
   * @return Autogenerated values
   */
  def insertAndGetId(stmt: Statement): Long = {
    logger.info("Executing insert:\n" + stmt)
    executeUpdateAndGetGeneratedKeys(stmt).getLong("id")
  }
  /**
   * @return How many rows deleted
   */
  def delete(stmt: Statement): Int = {
    logger.info("Executing delete:\n" + stmt)
    executeUpdate(stmt)
  }
  private def executeUpdateAndGetGeneratedKeys(stmt: Statement) = {
    if (stmt.data.isEmpty) {
      val js = connection.createStatement()
      js.executeUpdate(stmt.sql).ensuring(_ == 1)
      js.getGeneratedKeys
    } else {
      val js = preparedStatement(stmt, true)
      js.executeUpdate().ensuring(_ == 1)
      js.getGeneratedKeys
    }
  }
  private def executeUpdate(stmt: Statement) = {
    if (stmt.data.isEmpty) connection.createStatement().executeUpdate(stmt.sql)
    else preparedStatement(stmt).executeUpdate()
  }
  private def preparedStatement(stmt: Statement, generatedKeys: Boolean = false) = {
    val s =
      connection.prepareStatement(
        stmt.sql,
        if (generatedKeys) JStatement.RETURN_GENERATED_KEYS
        else JStatement.NO_GENERATED_KEYS
      )
    stmt.data.zipWithIndex.foreach {
      case (v, i) => s.set(i, v)
    }

    s
  }


}