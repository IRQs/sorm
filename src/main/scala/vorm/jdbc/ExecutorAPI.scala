package vorm.jdbc

import worm.reflection._
import worm.util.Extensions._
import com.weiglewilczek.slf4s.Logging
import worm.reflection.ReflectionUtil._
import java.sql.{ResultSet, PreparedStatement, Connection, Statement => JStatement}

trait ExecutorAPI extends Logging {
  protected def connection: Connection

  /**
   * @return Parsed results
   */
  protected def executeSelect(stmt: Statement): List[AnyRef] = {
    throw new UnsupportedOperationException("TODO")
  }
  /**
   * @return How many rows updated
   */
  protected def update(stmt: Statement): Int = {
    logger.info("Executing update:\n" + stmt)
    executeUpdate(stmt)
  }
  /**
   * Either throw an exception or perform an insert and return autogenerated values result set for parsing
   * @return Autogenerated values
   */
  protected def insert(stmt: Statement): () => ResultSet = {
    logger.info("Executing insert:\n" + stmt)
    executeUpdateAndGetGeneratedKeys(stmt)
  }
  /**
   * @return How many rows deleted
   */
  protected def delete(stmt: Statement): Int = {
    logger.info("Executing delete:\n" + stmt)
    executeUpdate(stmt)
  }
  private def executeUpdateAndGetGeneratedKeys(stmt: Statement): () => ResultSet = {
    if (stmt.data.isEmpty) {
      val js = connection.createStatement()
      js.executeUpdate(stmt.sql).ensuring(_ == 1)
      js.getGeneratedKeys
    }
    else {
      val js = prepareJDBCStatement(stmt, true)
      js.executeUpdate().ensuring(_ == 1)
      js.getGeneratedKeys
    }
  }
  private def executeUpdate(stmt: Statement) = {
    if (stmt.data.isEmpty) connection.createStatement().executeUpdate(stmt.sql)
    else prepareJDBCStatement(stmt).executeUpdate()
  }
  private def prepareJDBCStatement(stmt: Statement, generatedKeys: Boolean = false) = {
    connection.prepareStatement(stmt.sql, if (generatedKeys) JStatement.RETURN_GENERATED_KEYS else JStatement.NO_GENERATED_KEYS).tap(s =>
      stmt.data.indices.foreach(i =>
        stmt.data(i).tap {case (v, t) => setJDBCStmtVar(s, i + 1, v, t)}
      )
    )
  }
  /**
   * @see <a href=http://docstore.mik.ua/orelly/java-ent/servlet/ch09_02.htm#ch09-22421>jdbc table
   */
  private def setJDBCStmtVar(s: PreparedStatement, n: Int, v: Any, t: TypeReflection) {
    t match {
      case _ if t.is[String] => s.setString(n, v.asInstanceOf[String])
      case _ if t.is[java.math.BigDecimal] => s.setBigDecimal(n, v.asInstanceOf[java.math.BigDecimal])
      case _ if t.is[BigDecimal] => s.setBigDecimal(n, v.asInstanceOf[BigDecimal].bigDecimal)
      case _ if t.is[Boolean] => s.setBoolean(n, v.asInstanceOf[Boolean])
      case _ if t.is[Integer] || t.is[Int] => s.setInt(n, v.asInstanceOf[Int])
      case _ if t.is[Long] => s.setLong(n, v.asInstanceOf[Long])
      case _ if t.is[Float] => s.setFloat(n, v.asInstanceOf[Float])
      case _ if t.is[Double] => s.setDouble(n, v.asInstanceOf[Double])
      case _ => throw new UnsupportedOperationException("Type " + t.typeName + " not supported")
    }
  }


}